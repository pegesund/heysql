"
""note that there is no binding between this function and rest of heysql, so can tables
	in practice be done from pure sql code as well.
	
	Dictionary should be oncreateTableCellButtonUsing: 
	colors := Dictionary personDict { 
	   'id' -> 'serial' . 
	   'forname' -> 'textt' . 
	   'surname' -> 'json' 
	}. 

	All P3-types can be used, look them up for a complete list
"
Class {
	#name : #HeySql,
	#superclass : #Object,
	#instVars : [
		'id'
	],
	#classVars : [
		'Client',
		'DbFields',
		'DbFieldsLowercased',
		'Statements'
	],
	#category : #'HeySql-Initialize'
}

{ #category : #connection }
HeySql class >> connect: client [
	"First connect through p3 as usual, and pass the client on to this class. Reuse client if allready set"
	Client := client.
	client ifNil: [ Client := client ]
]

{ #category : #accessing }
HeySql class >> connection [
	"return the db connection"
	^ Client.

]

{ #category : #initialization }
HeySql class >> createTable: tableName tableDict: tableDict [
	"helper function to quick create table based on a heysql instance
        note that there is no binding between this function and rest of heysql, so can tables
        in practice be done from pure sql code as well.
        
        Dictionary should be oncreateTableCellButtonUsing:
        personDict := Dictionary newFrom { 
           'id' -> 'serial' .
           'forname' -> 'textt' . 
           'surname' -> 'json' 
        }.

        All P3-types can be used, look them up for a complete list"

	| sqlString |
	sqlString := 'create table {1} (' format: {tableName}.
	tableDict
		keysAndValuesDo: [ :fieldName :fieldType | 
			sqlString := sqlString , '{1} {2},'
				format:
					{fieldName.
					fieldType} ].
	Client execute: (sqlString allButLast , ')').			
]

{ #category : #accessing }
HeySql class >> dbFields [
	"returns the fields to be handled by heysql as a string. If the dbFields: function is not called, we use all instance variables from the class, including superclasses of type heysql"

	| key |
	key := self asString.
	(DbFields includesKey: key)
		ifFalse: [ | classes dbfields |
			classes := self allSuperclasses
				select: [ :c | c respondsTo: #dbFields ].
			dbfields := classes , {self}
				flatCollect: [ :c | 
					(DbFields includesKey: c asString)
						ifTrue: [ DbFields at: c asString ]
						ifFalse: [ c instVarNames collect: [ :v | v asString ] ] ].
			dbfields := dbfields asSet asSortedCollection.
			dbfields remove: 'id'.
			DbFields at: key put: dbfields ].
	^ DbFields at: key
]

{ #category : #accessing }
HeySql class >> dbFields: allFields [
	"Set fields which also have column in database"

	| fields |
	fields := (allFields splitOn: ' ') asSet.
	DbFields at: self asString put: fields asArray.
	self generateGettersAndSetters
]

{ #category : #'private ' }
HeySql class >> dbFieldsLc: dbLc theClass: theClass [
	"translates between lower case results in pg and method names with upper case. populates class lazyly"

	(DbFieldsLowercased includesKey: theClass)
		ifFalse: [ (DbFields at: theClass)
				do: [ :key | DbFieldsLowercased at: key asLowercase put: key ].
				DbFieldsLowercased at: 'id' put: 'id' ].
	^ DbFieldsLowercased at: dbLc
]

{ #category : #connection }
HeySql class >> disConnect [
	"disConnect the db-client"
	Client close

]

{ #category : #'private ' }
HeySql class >> findNumberOfParams: sql [
	"Iterates over a P3-executable and finds number of sql-params, namely those who starts with $"

	| s |
	s := Set new.
	sql regex: '[$]\d+' matchesCollect: [ :r | s add: r ]. 
	^ s size
]

{ #category : #initialization }
HeySql class >> generateGettersAndSetters [
	"Generete getters and setters for all db-fields. Db-fields should allready be set with DbFields"

	self dbFields
		do: [ :field | 
			| getter setter |
			getter := '
	    {1} 
	    "Autogenerated HeySql getter"
	    ^{1}.
	  ' format: {field}.
			setter := '
	    {1}: x  
	    "Autogenerated HeySql setter"
	    {1} := x.
		 ^ x.
	  ' format: {field}.
			self compile: getter classified: 'accessor'.
			self compile: setter classified: 'accessor' ]
]

{ #category : #'private ' }
HeySql class >> generateSimpleDbOperationInsert: tableName [
	"Generate methods for inserting and updating. Before running this method setDbFiels must have been called"

	| sqlInsert fields values heysqlInsertDb |
	fields := self dbFields joinUsing: ','.
	values := (Interval from: 1 to: self dbFields size)
		collect: [ :i | '$' , i asString ].
	sqlInsert := 'insert into {1}({2}) values({3}) returning id'
		format:
			{tableName.
			fields.
			(values joinUsing: ',')}.
	heysqlInsertDb := Client prepare: sqlInsert.
	Statements at: ('heysql_insert_' , tableName) put: heysqlInsertDb.

]

{ #category : #'private ' }
HeySql class >> generateSimpleDbOperationUpdate: tableName [
	"generate update statment and method on object"

	| sqlUpdate fields values updateFields statement |
	fields := self dbFields select: [ :f | f ~~ 'id' ].
	values := (Interval from: 1 to: self dbFields size)
		collect: [ :i | '$' , i asString ].
	updateFields := fields with: values collect: [ :f :v | f , '=' , v ].
	sqlUpdate := 'update {1} set {2} where id = {3}'
		format:
			{tableName.
			(updateFields joinUsing: ', ').
			('$' , (fields size + 1) asString)}.
	statement := Client prepare: sqlUpdate.
	Statements at: 'heysql_update_' , tableName put: statement
]

{ #category : #initialization }
HeySql class >> generateSimpleDbOperations: tableName [
	"generate insert and update statemens and methods for the object. setDbFields must have been done before doing this."

	self generateSimpleDbOperationInsert: tableName.
	self generateSimpleDbOperationUpdate: tableName
]

{ #category : #initialization }
HeySql class >> generateSqlMethods: dict [
	"Iterating over all key-value elements in a dictionary and creates methods based on these. It is based on P3-postgres syntax.
	 sql-functions with parameter need to be declared ending with colon, like always in smalltalk "

	"Example: 
	
	d := Dictionary newFrom: 
	{ 'allBooks' -> 'select * from books' . 
  	  'allCustomerWithMoreThanOnePurches' -> 'select, join and have sql-fun here' 
	  'queryWithTwoParamsParam1, param2' -> 'select something where x = $1 and y = $2 ]  '
	}. 
	
	"

	
	dict
		keysAndValuesDo: [ :methodNames :sql | 
			"self class compile: methodString classified: 'heysql' ]"
			| methodString numParamsInSql params methodNameMaybeParams executeParams allMethods |
			self generateSqlStatement: methodNames sql: sql.
			numParamsInSql := self findNumberOfParams: sql.
			params := numParamsInSql > 0
				ifTrue: [ (Interval from: 1 to: numParamsInSql)
						collect: [ :v | 'p' , v asString ] ]
				ifFalse: [ #() ].
			methodNameMaybeParams := numParamsInSql > 0
				ifTrue: [ allMethods := (methodNames splitOn: ',') collect: [ :s | s , ': ' ].
					(allMethods with: params collect: [ :s1 :s2 | s1 , s2 ])
						joinUsing: ' ' ]
				ifFalse: methodNames.
			executeParams := '{ ' , (params joinUsing: '. ') , ' }'.
			methodString := '
	     {1} 
	     "Autogenerated heysql-method"
	     | statement result |
	     statement := Statements at: ''{3}''.
	     result := statement query: {2}. 
	
	     ^ (self toObject: result).
	    '
				format:
					{methodNameMaybeParams.
					executeParams.
					(methodNames , '_', (self asString))}.
			self class compile: methodString classified: 'accessor' ]
]

{ #category : #'private ' }
HeySql class >> generateSqlStatement: methodName sql: sql [
	"Add an server side compiled statment which can be access from a slot"

	| statement |
	statement := Client prepare: sql.
	Statements at: (methodName , '_', (self asString)) put: statement
]

{ #category : #initialization }
HeySql class >> init [
	"init start variables"

	Statements := Dictionary new.
	DbFields := Dictionary new.
	DbFieldsLowercased := Dictionary new.
]

{ #category : #db }
HeySql class >> packageDbSetup: packageName [
	"Iterates over all classes in a package and calls dbSetup method on the method if found"

	| classes |
	classes := Smalltalk allClassesAndTraits
		select: [ :theClass | 
			| className |
			className := theClass category asString.
			(className beginsWith: packageName)
				& ((className findString: 'Manifest') = 0) ].
	classes
		do: [ :theClass | 
			Transcript show: theClass.
			(theClass respondsTo: #dbSetup)
				ifTrue: [ theClass dbSetup ] ]
]

{ #category : #'private ' }
HeySql class >> toObject: rSet [
	"Convert P3-result to an object. This is done by reflecion - iterating over all fields."

	| methodFields manyObjects res theClassStr |
	methodFields := rSet data
		collect: [ :row | 
			(rSet descriptions collect: [ :f | f fieldName ])
				with: row
				collect: [ :f1 :f2 | 
					{f1.
					f2} ] ].
	theClassStr := self asString.
	manyObjects := methodFields
		collect: [ :row | 
			| obj |
			obj := self new.
			row
				do: [ :field | 
					obj
						perform: ((self dbFieldsLc: field first theClass: theClassStr ) , ':') asSymbol
						withArguments: {field second} ].
			obj ].
	manyObjects isEmpty
		ifTrue: [ ^ nil ].
	res := manyObjects size > 1
		ifTrue: [ manyObjects ]
		ifFalse: [ manyObjects first ].
	^ res
]

{ #category : #db }
HeySql >> getTableName [
	^ self className .
]

{ #category : #accessor }
HeySql >> id [ 
	    "Autogenerated HeySql getter"
	    ^id.
	  
]

{ #category : #accessor }
HeySql >> id: x [  
	    "Autogenerated HeySql setter"
	    id := x.
	  
]

{ #category : #db }
HeySql >> insert [
	"HeySql autogenerated method for inserting objects"

	| values res newId statementName statement |
	values := self class dbFields
		collect: [ :field | self perform: field asSymbol ].
	statementName := 'heysql_insert_' , self className .
	(Statements includesKey: statementName)
		ifFalse: [ self class generateSimpleDbOperations: self getTableName ].
	statement := Statements at: statementName.
	res := statement query: values.
	newId := (res data at: 1) at: 1.
	self id: newId.
	^ res
]

{ #category : #documenting }
HeySql >> notes [
	" 
	TEST
	myDict keysAndValuesDo: [ :key :value | value doSomething ].
	Dictionary newFrom: {1 -> 7. 2 -> 3. 3 -> 1. 4 -> 3}
	s := Set new.
'this is {1} and {2}' regex: '{\d+}' matchesCollect: [ :r |
	s add: r].
s size.
	
	(Smalltalk classNamed: clsName) methodName: arg. (maybe param, but check more params) 
	
	Transcript show: o class asString.
	
	'HeySql' asClass .
	
	s := Set new.
'this is {1} and {2}' regex: '{\d+}' matchesCollect: [ :r |
	s add: r].
s size.
	
	5 perform: ('factorial' asSymbol ) og 4 perform: #max: withArguments
	
!! Encode

x := (ZnCharacterEncoder newForEncoding: 'utf8')
      encodeString: 'Les élèves Français'.

(ZnCharacterEncoder newForEncoding: 'utf8') decodeBytes: x		
	
	"

	<wikiStyleHelp: #'The name of the book I want to write'>
	
]

{ #category : #db }
HeySql >> update [
	"HeySql autogenerated method for inserting objects"

	| values res fields statementName statement |
	fields := self class dbFields.
	values := fields collect: [ :field | self perform: field asSymbol ].
	statementName := 'heysql_update_' , self className .
	(Statements includesKey: statementName)
		ifFalse: [ self class generateSimpleDbOperations: self getTableName ].
	statement := Statements at: statementName.
	res := statement query: values , {id}.
	^ res
]
