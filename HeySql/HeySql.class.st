"
""note that there is no binding between this function and rest of heysql, so can tables
	in practice be done from pure sql code as well.
	
	Dictionary should be oncreateTableCellButtonUsing: 
	colors := Dictionary personDict { 
	   'id' -> 'serial' . 
	   'forname' -> 'textt' . 
	   'surname' -> 'json' 
	}. 

	All P3-types can be used, look them up for a complete list
"
Class {
	#name : #HeySql,
	#superclass : #Object,
	#instVars : [
		'id'
	],
	#classVars : [
		'DbFields',
		'DbFieldsLowercased',
		'Pool',
		'SharedClient',
		'Statements',
		'Url'
	],
	#category : #'HeySql-Initialize'
}

{ #category : #converting }
HeySql class >> asArray: hres [

	"Transform a heysql result to an array"

	hres ifNil: [ ^ {  } ].
	(hres isCollection) ifTrue: [ ^ hres ].
	^ { hres }
]

{ #category : #db }
HeySql class >> byAll [

	"HeySql autogenerated method for inserting objects"

	| statementName |
	statementName := 'heysql_byall_' , self asString asLowercase.
	(Statements includesKey: statementName) ifFalse: [ 
		self generateSimpleDbOperations: self asString asLowercase ].
	LocalClient value ifNotNil: [ 
		^ self byAllclient: LocalClient value statementName: statementName ].
	Pool withConnection: [ :client | 
		^ self byAllclient: client statementName: statementName ]
]

{ #category : #db }
HeySql class >> byAllclient: client statementName: statementName [

	"HeySql autogenerated method for inserting objects"

	| res statement |
	[ 
	statement := client preparedStatementNamed: statementName.
	res := statement query: { }.
	^ self toObject: res ]
		on: NotFound
		do: [ 
			self generateSimpleDbOperations: self asString asLowercase.
			self prepareStatements: client.
			statement := client preparedStatementNamed: statementName.
			res := statement query: { }..
			^ self toObject: res ]
]

{ #category : #db }
HeySql class >> byId: theId [
	"HeySql autogenerated method for inserting objects"

	| statementName |
	statementName := 'heysql_byid_' , self asString asLowercase.
	(Statements includesKey: statementName)
		ifFalse: [ self generateSimpleDbOperations: self asString asLowercase ].
	LocalClient value
		ifNotNil: [ ^ self
				byId: theId
				client: LocalClient value
				statementName: statementName ].
	Pool
		withConnection: [ :client | 
			^ self
				byId: theId
				client: client
				statementName: statementName ]
]

{ #category : #db }
HeySql class >> byId: theId client: client statementName: statementName [
	"HeySql autogenerated method for inserting objects"

	| res statement |
	[ statement := client preparedStatementNamed: statementName.
	res := statement query: {theId}.
	^ self toObject: res ]
		on: NotFound
		do: [ self generateSimpleDbOperations: self asString asLowercase.
			self prepareStatements: client.
			statement := client preparedStatementNamed: statementName.
			res := statement query: {theId}.
			^ self toObject: res ]
]

{ #category : #db }
HeySql class >> closePool [
	Pool close.
	


]

{ #category : #initialization }
HeySql class >> createTable: tableName tableDict: tableDict [
	"helper function to quick create table based on a heysql instance
        note that there is no binding between this function and rest of heysql, so can tables
        in practice be done from pure sql code as well.
        
        Dictionary should be oncreateTableCellButtonUsing:
        personDict := Dictionary newFrom { 
           'id' -> 'serial' .
           'forname' -> 'textt' . 
           'surname' -> 'json' 
        }.

        All P3-types can be used, look them up for a complete list"

	| sqlString client |
	sqlString := 'create table {1} (' format: {tableName}.
	tableDict
		keysAndValuesDo: [ :fieldName :fieldType | 
			sqlString := sqlString , '{1} {2},'
				format:
					{fieldName.
					fieldType} ].
	client := self sharedClient.
	client execute: sqlString allButLast , ')'.

]

{ #category : #accessing }
HeySql class >> dbFields [
	"returns the fields to be handled by heysql as a string. If the dbFields: function is not called, we use all instance variables from the class, including superclasses of type heysql"

	| key |
	key := self asString.
	(DbFields includesKey: key)
		ifFalse: [ | classes dbfields |
			classes := self allSuperclasses
				select: [ :c | c respondsTo: #dbFields ].
			dbfields := classes , {self}
				flatCollect: [ :c | 
					(DbFields includesKey: c asString)
						ifTrue: [ DbFields at: c asString ]
						ifFalse: [ c instVarNames collect: [ :v | v asString ] ] ].
			dbfields := dbfields asSet asSortedCollection.
			dbfields remove: 'id'.
			DbFields at: key put: dbfields ].
	^ DbFields at: key
]

{ #category : #accessing }
HeySql class >> dbFields: allFields [
	"Set fields which also have column in database"

	| fields |
	fields := (allFields splitOn: ' ') asSet.
	DbFields at: self asString put: fields asArray.
	self generateGettersAndSetters
]

{ #category : #'private ' }
HeySql class >> dbFieldsLc: dbLc theClass: theClass [
	"translates between lower case results in pg and method names with upper case. populates class lazyly"

	(DbFieldsLowercased includesKey: theClass)
		ifFalse: [ (DbFields at: theClass)
				do: [ :key | DbFieldsLowercased at: key asLowercase put: key ].
				DbFieldsLowercased at: 'id' put: 'id' ].
	^ DbFieldsLowercased at: dbLc
]

{ #category : #initialization }
HeySql class >> dbSetup [
	"Override this method when creating sql-queries. See docs on github"

]

{ #category : #db }
HeySql class >> deleteById: theId [
	"HeySql autogenerated method for inserting objects"

	|  statementName  |
	statementName := 'heysql_deletebyid_' , self asString asLowercase.
	(Statements includesKey: statementName)
		ifFalse: [ self generateSimpleDbOperations: self asString asLowercase ].
	LocalClient value
		ifNotNil: [ ^ self
				deleteById: theId
				client: LocalClient value
				statementName: statementName ].
	Pool
		withConnection:
			[ :client | ^ self deleteById: theId client: client statementName: statementName ]
]

{ #category : #db }
HeySql class >> deleteById: theId client: client statementName: statementName [
	"HeySql autogenerated method for inserting objects"

	| res statement |
			[ statement := client preparedStatementNamed: statementName.
			res := statement query: {theId}.
			^ self toObject: res ]
				on: NotFound
				do: [ self generateSimpleDbOperations: self asString asLowercase.
					self prepareStatements: client.
					statement := client preparedStatementNamed: statementName.
					res := statement query: {theId}.
					^ self toObject: res ]
]

{ #category : #'private ' }
HeySql class >> executePreparedStatementSafe: statementName values: values [
	"executes a prepared statment, generates missing statments if not found"

	LocalClient value
		ifNotNil: [ ^ self
				executePreparedStatementSafe: statementName
				values: values
				client: LocalClient value ].
	Pool
		withConnection: [ :client | 
			^ self
				executePreparedStatementSafe: statementName
				values: values
				client: client ]
]

{ #category : #'private ' }
HeySql class >> executePreparedStatementSafe: statementName values: values client: client [
	"executes a prepared statment, generates missing statments if not found"

	| statement |
			[ statement := client preparedStatementNamed: statementName.
			^ statement query: values ]
				on: NotFound
				do: [ self prepareStatements: client.
					statement := client preparedStatementNamed: statementName.
					^ statement query: values ] 
]

{ #category : #'private ' }
HeySql class >> findNumberOfParams: sql [
	"Iterates over a P3-executable and finds number of sql-params, namely those who starts with $"

	| s |
	s := Set new.
	sql regex: '[$]\d+' matchesCollect: [ :r | s add: r ]. 
	^ s size
]

{ #category : #initialization }
HeySql class >> generateGettersAndSetters [

	"Generete getters and setters for all db-fields. Db-fields should allready be set with DbFields"

	| theObject |
	self dbFields do: [ :field | 
		| getter setter |
		getter := '
	    {1} 
	    "Autogenerated HeySql getter"
	    ^{1}.
	  ' format: { field }.
		setter := '
	    {1}: x  
	    "Autogenerated HeySql setter"
	    {1} := x.
		 ^ self.
	  ' format: { field }.
		theObject := self new.
		(theObject respondsTo: field asSymbol) ifFalse: [ 
			self compile: getter classified: 'accessor' ].
		(theObject respondsTo: (field , ':') asSymbol) ifFalse: [ 
			self compile: setter classified: 'accessor' ] ]
]

{ #category : #'private ' }
HeySql class >> generateSimpleDbOperationById: tableName [

	"generate byId-method"

	| sqlSelect |
	sqlSelect := 'select * from {1} where id = $1' format: { tableName }.
	Statements at: 'heysql_byid_' , tableName put: sqlSelect.
	
	sqlSelect := 'select * from {1}' format: { tableName }.
	Statements at: 'heysql_byall_' , tableName put: sqlSelect.
]

{ #category : #'private ' }
HeySql class >> generateSimpleDbOperationDeleteById: tableName [
	"generate byId-method"

	| sqlSelect |
	sqlSelect := 'delete from {1} where id = $1' format: {tableName}.
	Statements at: 'heysql_deletebyid_' , tableName put: sqlSelect
]

{ #category : #'private ' }
HeySql class >> generateSimpleDbOperationInsert: tableName [
	"Generate methods for inserting and updating. Before running this method setDbFiels must have been called"

	| sqlInsert fields values |
	fields := self dbFields joinUsing: ','.
	values := (Interval from: 1 to: self dbFields size)
		collect: [ :i | '$' , i asString ].
	sqlInsert := 'insert into {1}({2}) values({3}) returning id'
		format:
			{tableName.
			fields.
			(values joinUsing: ',')}.
	Statements at: 'heysql_insert_' , tableName put: sqlInsert
]

{ #category : #'private ' }
HeySql class >> generateSimpleDbOperationUpdate: tableName [
	"generate update statment and method on object"

	| sqlUpdate fields values updateFields |
	fields := self dbFields select: [ :f | f ~~ 'id' ].
	values := (Interval from: 1 to: self dbFields size)
		collect: [ :i | '$' , i asString ].
	updateFields := fields with: values collect: [ :f :v | f , '=' , v ].
	sqlUpdate := 'update {1} set {2} where id = {3}'
		format:
			{tableName.
			(updateFields joinUsing: ', ').
			('$' , (fields size + 1) asString)}.
	Statements at: 'heysql_update_' , tableName put: sqlUpdate
]

{ #category : #initialization }
HeySql class >> generateSimpleDbOperations: tableName [
	"generate insert and update statemens and methods for the object. setDbFields must have been done before doing this."

	self generateSimpleDbOperationInsert: tableName.
	self generateSimpleDbOperationUpdate: tableName.
	self generateSimpleDbOperationById: tableName.
	self generateSimpleDbOperationDeleteById: tableName
]

{ #category : #initialization }
HeySql class >> generateSqlMethods: dict [
	"Iterating over all key-value elements in a dictionary and creates methods based on these. It is based on P3-postgres syntax.
	 sql-functions with parameter need to be declared ending with colon, like always in smalltalk "

	"Example: 
	
	d := Dictionary newFrom: 
	{ 'allBooks' -> 'select * from books' . 
  	  'allCustomerWithMoreThanOnePurches' -> 'select, join and have sql-fun here' 
	  'queryWithTwoParamsParam1, param2' -> 'select something where x = $1 and y = $2 ]  ' 
	}. 
	
	"

	dict
		keysAndValuesDo: [ :methodNames :sql | 
			"self class compile: methodString classified: 'heysql' ]"
			| methodString numParamsInSql params methodNameMaybeParams executeParams allMethods methodNameStatement |
			methodNameStatement := methodNames , '_' , self asString.
			self generateSqlStatement: methodNames sql: sql.
			numParamsInSql := self findNumberOfParams: sql.
			params := numParamsInSql > 0
				ifTrue: [ (Interval from: 1 to: numParamsInSql)
						collect: [ :v | 'p' , v asString ] ]
				ifFalse: [ #() ].
			methodNameMaybeParams := numParamsInSql > 0
				ifTrue: [ allMethods := (methodNames splitOn: ',') collect: [ :s | s , ': ' ].
					(allMethods with: params collect: [ :s1 :s2 | s1 , s2 ])
						joinUsing: ' ' ]
				ifFalse: methodNames.
			executeParams := '{ ' , (params joinUsing: '. ') , ' }'.
			methodString := '
	     {1} 
	     "Autogenerated heysql-method"
	     | result |
	     result := self executePreparedStatementSafe: ''{3}'' values: {2}.
	     ^ (self toObject: result).
	    '
				format:
					{methodNameMaybeParams.
					executeParams.
					methodNameStatement}.
			self class compile: methodString classified: 'accessor' ]
]

{ #category : #'private ' }
HeySql class >> generateSqlStatement: methodName sql: sql [
	"Add an server side compiled statment which can be access from a slot"

	Statements at: methodName , '_' , self asString put: sql
]

{ #category : #db }
HeySql class >> getPool [
	^ Pool

]

{ #category : #'private-initialization' }
HeySql class >> init [
	"does not do something for now"

]

{ #category : #initialization }
HeySql class >> init: url [
	"init start variables"

	Statements := Dictionary new.
	DbFields := Dictionary new.
	DbFieldsLowercased := Dictionary new.
	Pool := P3ConnectionPool url: url.
	self url: url
	
]

{ #category : #db }
HeySql class >> packageDbSetup: packageName [

	"Iterates over all classes in a package and calls dbSetup method on the method if found"

	| classes |
	classes := Smalltalk allClassesAndTraits select: [ :theClass | 
		           | className |
		           className := theClass category asString.
		           (className beginsWith: packageName)
		           & ((className findString: 'Manifest') = 0) ].

	classes := classes select: [ :c | 
		           (c asString findString: 'Base') = 0 ].
	Transcript
		show: 'Generating heysql-functionality';
		cr.
	classes do: [ :theClass | 
		Transcript
			show: theClass;
			cr.
		theClass generateGettersAndSetters.
		(theClass new isKindOf: (Smalltalk at: #Generic ifAbsent: [ nil ])) ifFalse: [ 
			theClass generateSimpleDbOperations: theClass new getTableName ].
		(theClass respondsTo: #dbSetup) ifTrue: [ theClass dbSetup ] ]
]

{ #category : #accessing }
HeySql class >> pool: anObject [
	Pool := anObject
]

{ #category : #db }
HeySql class >> prepareStatements: client [
	"prepare statments for a new connection."

	self assert: client isWorking.
	Statements
		keysAndValuesDo:
			[ :statementName :sql | | statement |
			[  statement := client preparedStatementNamed: statementName.
			 	statement close.
			 ] on: Error do: [ nil ].
			client prepare: sql named: statementName ]
]

{ #category : #accessing }
HeySql class >> sharedClient [
	^ SharedClient
]

{ #category : #accessing }
HeySql class >> sharedClient: anObject [
	SharedClient := anObject
]

{ #category : #accessing }
HeySql class >> statements [
	^ Statements
]

{ #category : #accessing }
HeySql class >> statements: anObject [
	Statements := anObject
]

{ #category : #transformations }
HeySql class >> toJsonDictionary: res [
	"Transform heysql-result to a dictkonary in a json-safe way"

	(res isKindOf: self)
		ifTrue: [ ^ {res asDictionary} ].
	(res isKindOf: Collection)
		ifTrue: [ ^ res collect: [ :r | r asDictionary ] ].
	^ {} 
]

{ #category : #'private ' }
HeySql class >> toObject: rSet [
	"Convert P3-result to an object. This is done by reflecion - iterating over all fields."

	| methodFields manyObjects res theClassStr |
	methodFields := rSet data
		collect: [ :row | 
			(rSet descriptions collect: [ :f | f fieldName ])
				with: row
				collect: [ :f1 :f2 | 
					{f1.
					f2} ] ].
	theClassStr := self asString.
	manyObjects := methodFields
		collect: [ :row | 
			| obj |
			obj := self new.
			row
				do: [ :field | 
					obj
						perform: ((self dbFieldsLc: field first theClass: theClassStr ) , ':') asSymbol
						withArguments: {field second} ].
			obj ].
	manyObjects isEmpty
		ifTrue: [ ^ nil ].
	res := manyObjects size > 1
		ifTrue: [ manyObjects ]
		ifFalse: [ manyObjects first ].
	^ res
]

{ #category : #accessing }
HeySql class >> url [
	^ Url
]

{ #category : #accessing }
HeySql class >> url: anObject [
	Url := anObject
]

{ #category : #accessing }
HeySql >> asDictionary [

	"comment stating purpose of instance-side method"

	| vars dict val |
	vars := self class dbFields collect: [ :v | v asSymbol ].
	vars add: #id.
	dict := Dictionary new.
	vars do: [ :var | 
		val := (self respondsTo: var)
			       ifTrue: [ self perform: var ]
			       ifFalse: [ self instVarNamed: var ].
		(val isKindOf: DateAndTime) ifTrue: [ val := val asString ].
		val ifNotNil: 
		[dict at: var asString put: val] ].
	^ dict
]

{ #category : #db }
HeySql >> getTableName [
	^ self className asLowercase.
]

{ #category : #accessor }
HeySql >> id [ 
	    "Autogenerated HeySql getter"
	    ^id.
	  
]

{ #category : #accessor }
HeySql >> id: x [  
	    "Autogenerated HeySql setter"
	    id := x.
	  
]

{ #category : #db }
HeySql >> insert [
	"HeySql autogenerated method for inserting objects"

	| values statementName |
	values := self class dbFields
		collect: [ :field | self perform: field asSymbol ].
	statementName := 'heysql_insert_' , self getTableName.
	(Statements includesKey: statementName)
		ifFalse: [ self class generateSimpleDbOperations: self getTableName ].
	LocalClient value
		ifNotNil: [ 
			^ self
				insertClient: LocalClient value
				values: values
				statementName: statementName ].
	Pool
		withConnection: [ :client | 
			^ self
				insertClient: client
				values: values
				statementName: statementName ]
]

{ #category : #db }
HeySql >> insertClient: client values: values statementName: statementName [
	"HeySql autogenerated method for inserting objects"

	| res newId  statement |
	[ statement := client preparedStatementNamed: statementName.
	res := statement query: values.
	newId := (res data at: 1) at: 1.
	self id: newId.
	^ res ]
		on: NotFound
		do: [ self class generateSimpleDbOperations: self getTableName.
			self class prepareStatements: client.
			statement := client preparedStatementNamed: statementName.
			res := statement query: values.
			newId := (res data at: 1) at: 1.
			self id: newId.
			^ res ]
]

{ #category : #documenting }
HeySql >> notes [
	" 
	TEST
	myDict keysAndValuesDo: [ :key :value | value doSomething ].
	Dictionary newFrom: {1 -> 7. 2 -> 3. 3 -> 1. 4 -> 3}
	s := Set new.
'this is {1} and {2}' regex: '{\d+}' matchesCollect: [ :r |
	s add: r].
s size.
	
	(Smalltalk classNamed: clsName) methodName: arg. (maybe param, but check more params) 
	
	Transcript show: o class asString.
	
	'HeySql' asClass .
	
	s := Set new.
'this is {1} and {2}' regex: '{\d+}' matchesCollect: [ :r |
	s add: r].
s size.
	
	5 perform: ('factorial' asSymbol ) og 4 perform: #max: withArguments
	
!! Encode

x := (ZnCharacterEncoder newForEncoding: 'utf8')
      encodeString: 'Les élèves Français'.

(ZnCharacterEncoder newForEncoding: 'utf8') decodeBytes: x		
	
	"

	
]

{ #category : #db }
HeySql >> update [
	"HeySql autogenerated method for inserting objects"

	| values fields statementName  |
	fields := self class dbFields.
	values := fields collect: [ :field | self perform: field asSymbol ].
	statementName := 'heysql_update_' , self getTableName.
	LocalClient value
		ifNotNil: [ ^ self
				updateClient: LocalClient value
				values: values
				statementName: statementName ].
	Pool
		withConnection: [ :client | 
			^ self
				updateClient: client
				values: values
				statementName: statementName ]
]

{ #category : #db }
HeySql >> updateClient: client values: values statementName: statementName [
	"HeySql autogenerated method for inserting objects"

	| statement |
	[ statement := client preparedStatementNamed: statementName.
	^ statement query: values , {id} ]
		on: NotFound
		do: [ self class generateSimpleDbOperations: self getTableName.
			self class prepareStatements: client.
			statement := client preparedStatementNamed: statementName.
			^ statement query: values , {id} ]
]

{ #category : #accessing }
HeySql >> validate [
	"Validates the instance variables, return #ok or a dict with the errors"
	| errs |
	errs := Dictionary new.
	self validateRules: errs.
	errs isEmpty
		ifTrue: [ ^ #ok ].
	^ errs
]

{ #category : #validating }
HeySql >> validateIds: errs [

	"Validate all fields with ids. Validate only if field is not empty!"

	| theClass possibleEntity foreignId |
	self class dbFields do: [ :f | 
		((f endsWith: 'Id') and: [ self respondsTo: f asSymbol ]) ifTrue: [ 
			foreignId := self perform: f asSymbol.
			foreignId ifNotNil: [ 
				theClass := (f readStream upToAll: 'Id') capitalized asClass.
				possibleEntity := theClass byId: foreignId.
				possibleEntity ifNil: [ errs at: f put: 'wrong id' ] ] ] ]
]

{ #category : #accessing }
HeySql >> validateRules: errs [

	"Override this one"


]
