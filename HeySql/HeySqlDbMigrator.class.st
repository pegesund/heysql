"
This class handles the migration of the database.

Add class methods to this starting with mig_X where x is a number as we changes the databse.
"
Class {
	#name : #HeySqlDbMigrator,
	#superclass : #Object,
	#classVars : [
		'HeySqlMigrationClass'
	],
	#category : #'HeySql-Migrations'
}

{ #category : #db }
HeySqlDbMigrator class >> createMigration [
	"creates migration"

	^ self createMigrationHelper: nil
]

{ #category : #db }
HeySqlDbMigrator class >> createMigration: theClass [
	"creates migration"

	^ self createMigrationHelper: theClass .
]

{ #category : #private }
HeySqlDbMigrator class >> createMigrationHelper: classes [
	"This creates a migration with the current time as a part of the method name, remark the underscore.
	If classes is a String, then generate for all classes in package, if a class for that class or nil, just create an empty migration."

	| migrateTime tableTemplate method localVars |
	HeySqlMigrationClass.
	migrateTime := self getNow.
	localVars := ''.
	tableTemplate := classes
		ifNil: [ '' ]
		ifNotNil: [ localVars := '| table |'.
			(classes isKindOf: String)
				ifTrue: [ self createMigrationPackage: classes ]
				ifFalse: [ self createMigrationTempateOne: classes ] ].
	method := '
	   migrate_{1}
	   "HeySql autogenerated method for adding a migration. Add your code below here."
		{3}
	   {2}
	
	'
		format:
			{migrateTime.
			tableTemplate.
			localVars}.
	HeySqlMigrationClass class compile: method classified: 'db-migration'.
	^ migrateTime
]

{ #category : #db }
HeySqlDbMigrator class >> createMigrationPackage: packageName [
	"Based on the package name - iterate over all classes in the package and write templates for creating corresponding tb-tables, based on the instance vars. This method is just for now writing to much code when bootstrapping a project.
	Use like this: HeySqlDbMigrator createMigrationTemplate: 'Sakuraeco-Models'.
	Remark that there are no dependency analysys between the tables, so the output order of the tables is random 
	"

	| classes manyTables migrateTime method |
	classes := Smalltalk allClassesAndTraits
		select: [ :theClass | 
			| className |
			className := theClass category asString.
			(className beginsWith: packageName)
				& ((className findString: 'Manifest') = 0) ].
	manyTables := (classes
		collect: [ :c | self createMigrationTempateOne: c ]) joinUsing: ''.
	migrateTime := self getNow.
	method := '
	   migrate_{1}
	   "HeySql autogenerated method for adding a migration. Add your code below here."
	   | table |

		{2}
	
	'
		format:
			{migrateTime.
			manyTables}.
	HeySqlMigrationClass class compile: method classified: 'db-migration'.
	^ manyTables
]

{ #category : #private }
HeySqlDbMigrator class >> createMigrationTempateOne: theClass [
	"Returns a string containing a template for the class, no side effects"

	| vars table dbVars comment |
	comment := ('\\"-- Generated code for class: {1}"
	
		' format: {theClass asString}) withCRs.
	dbVars := (theClass dbFields) asSet.
	dbVars add: 'id'.
	vars := ((dbVars
		collect: [ :v | 
			'         ( ''{1}'' -> ''{2}'')'
				format:
					{v asString.
					(self findDbTypeFromName: v asString)} ]) asArray joinUsing: ' . \')
		withCRs.
	table := 'table := \{ \\{1} \\       \} asDictionary. \
			
	    HeySql createTable: ''{2}'' tableDict: table.
			
			'
		format:
			{vars.
			theClass new getTableName}.
	^ comment , table withCRs
]

{ #category : #private }
HeySqlDbMigrator class >> findDbTypeFromName: colname [
	"Based on the column name, return db type"

	colname = 'id'
		ifTrue: [ ^ 'serial primary key' ].
	(#('name' 'description' 'address' 'email' 'url' 'forename' 'surname' 'password' 'salt') includes: colname)
		ifTrue: [ ^ 'text' ].	
	(#('price' 'vat' 'discount' 'total') includes: colname)
		ifTrue: [ ^ 'numeric' ].	
	(colname beginsWith: 'zip')
		ifTrue: [ ^ 'text' ].		
	(colname endsWith: 'Date')
		ifTrue: [ ^ 'timestamp' ].
	(colname endsWith: 'Range')
		ifTrue: [ ^ 'integer' ].	
	(colname beginsWith: 'is')
		ifTrue: [  ((colname at: 3) isUppercase)
			ifTrue: [ ^ 'boolean' ]].
	(colname beginsWith: 'has')
		ifTrue: [  ((colname at: 4) isUppercase)
			ifTrue: [ ^ 'boolean' ]].
	(colname endsWith: 'Id')
		ifTrue: [ ^ 'integer references {1} (id)'
				format: {(colname copyFrom: 1 to: colname size - 2)} ].
	^ 'type'
]

{ #category : #db }
HeySqlDbMigrator class >> forceMigrateOne: methodName [
	"Note, this should be only used in special cases. It does not!! update the migration table"

	| method |
	method := ('migrate_' , methodName) asSymbol.
	self migrateSome: { method }.
]

{ #category : #private }
HeySqlDbMigrator class >> getCurrentMigrationFromDb [
	"get the latest migration date from the db"

	| res |
	res := nil.
	HeySql getPool
		withConnection: [ :client | 
			res := (client query: 'select mdate from migrations where id = 1')
				data.
			res isEmpty
				ifTrue: [ ^ #('0') ] ].
	^ res at: 1
]

{ #category : #private }
HeySqlDbMigrator class >> getNow [
	"returns now in migrate format"

	^ (ZTimestamp now asString copyReplaceAll: '-' with: '_')
		copyReplaceAll: ':'
		with: '_'
]

{ #category : #db }
HeySqlDbMigrator class >> migrate [
	"migrates database up to current version."

	| start stop |
	[ HeySql closePool ]
		on: Exception
		do: [ nil ].
	HeySql pool: (P3ConnectionPool url: HeySql url).
	HeySql getPool
		withConnection: [ :client | 
			client
				execute: 'create table if not exists migrations (id serial unique, mdate text)' ].
	start := self getCurrentMigrationFromDb at: 1.
	stop := self getNow.
	start >= stop
		ifTrue: [ ^ false ].
	self migratestart: start to: stop.
	^ true
]

{ #category : #private }
HeySqlDbMigrator class >> migrateSome: migrateMethods [
	"Migrate one or many methods"

	| lastUpdate counter |
	counter := 0.
	Transcript
		show: 'Doing migration';
		cr.
	HeySql getPool
		withConnection: [ :client | 
			HeySql sharedClient: client.
			Transcript
				show: 'Starting transaction';
				cr.
			client execute: 'begin transaction'.
			lastUpdate := nil.
			[ migrateMethods asSortedCollection
				do: [ :method | 
					Transcript
						show: '  Now migrating: ' , method;
						cr.
					HeySqlMigrationClass perform: method.
					lastUpdate := method ] ]
				on: Exception
				do: [ :ex | 
					counter := counter + 1.
					Transcript
						show: 'Rolling back migration: ' , ex asString;
						cr.
					client execute: 'rollback;'.
					Transcript
						show: 'Rollback executed';
						cr.
					ex pass.
					^ nil ].
			counter = 0
				ifTrue: [ lastUpdate notNil
						ifTrue: [ | theTime |
							theTime := (lastUpdate copyFrom: 9 to: (lastUpdate size)) asString.
							self updateMigrationTable: theTime ].
					Transcript
						show: 'Commiting';
						cr.
					client execute: 'commit;'.
					Transcript
						show: 'Done migration - success';
						cr ] ].
	^ lastUpdate
]

{ #category : #private }
HeySqlDbMigrator class >> migratestart: migrateStart to: migrateStop [
	"Used to run migratios. Use like this:
	DbMigrator migrate: '2019_10_06T11_15_16Z' to:  '2019_11_06T11_15_16Z'
	
	Note! Library does not check if these migrations allready has been run (will maybe be added soon)
	"

	| migrateMethods |
	migrateMethods := HeySqlMigrationClass class selectors
		select: [ :m | 
			| t |
			t := m asString copyFrom: 9 to: (m size).
			(m asString beginsWith: 'migrate_') & (t > migrateStart)
				& (t <= migrateStop) ].
	^ self migrateSome: migrateMethods
]

{ #category : #'instance creation' }
HeySqlDbMigrator class >> new: theClass [
	"constructor - call with the migration class name"
	HeySqlMigrationClass := theClass .

]

{ #category : #private }
HeySqlDbMigrator class >> updateMigrationTable: date [
	"Updates migration table with current date, creates table if needed"

	| update |
	HeySql getPool
		withConnection: [ :client | 
	update := 'insert into migrations(id, mdate) values (1, ''{1}'') on conflict(id) do update set mdate = ''{1}'''
		format: {date}.
	client execute: update ]
]
